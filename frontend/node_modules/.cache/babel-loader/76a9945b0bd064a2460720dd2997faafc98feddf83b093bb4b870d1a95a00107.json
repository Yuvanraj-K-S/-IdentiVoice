{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\voice-auth-system\\\\frontend\\\\src\\\\components\\\\VoiceRecorder.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { registerVoice, loginVoice } from '../utils/api';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst VoiceRecorder = ({\n  mode,\n  userData,\n  handleStatus\n}) => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [countdown, setCountdown] = useState(10);\n  const [audioBlob, setAudioBlob] = useState(null);\n  const [passphrase, setPassphrase] = useState('');\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const countdownRef = useRef(null);\n\n  // Cleanup function to ensure everything is reset\n  const cleanupRecording = () => {\n    if (mediaRecorderRef.current) {\n      try {\n        if (mediaRecorderRef.current.state !== 'inactive') {\n          mediaRecorderRef.current.stop();\n        }\n        if (mediaRecorderRef.current.stream) {\n          mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n        }\n      } catch (err) {\n        console.error('Error in cleanup:', err);\n      }\n    }\n    if (countdownRef.current) {\n      clearInterval(countdownRef.current);\n    }\n    mediaRecorderRef.current = null;\n    audioChunksRef.current = [];\n    setIsRecording(false);\n    setCountdown(10);\n  };\n  useEffect(() => {\n    return () => {\n      cleanupRecording();\n    };\n  }, []);\n  const startRecording = async () => {\n    try {\n      // Clean up any existing recording first\n      cleanupRecording();\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          channelCount: 1,\n          sampleRate: 16000\n        }\n      });\n      const options = {\n        mimeType: 'audio/webm'\n      };\n      mediaRecorderRef.current = new MediaRecorder(stream, options);\n      audioChunksRef.current = [];\n      mediaRecorderRef.current.ondataavailable = e => {\n        if (e.data && e.data.size > 0) {\n          audioChunksRef.current.push(e.data);\n        }\n      };\n      mediaRecorderRef.current.onerror = event => {\n        console.error('Recording error:', event.error);\n        handleStatus('Error during recording. Please try again.', 'error');\n        cleanupRecording();\n      };\n      mediaRecorderRef.current.onstop = async () => {\n        try {\n          if (audioChunksRef.current.length === 0) {\n            throw new Error('No audio data recorded');\n          }\n          const audioBlob = new Blob(audioChunksRef.current, {\n            type: 'audio/webm'\n          });\n          const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n          const arrayBuffer = await audioBlob.arrayBuffer();\n          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n          const wavBuffer = audioBufferToWav(audioBuffer);\n          const wavBlob = new Blob([wavBuffer], {\n            type: 'audio/wav'\n          });\n          setAudioBlob(wavBlob);\n          await processRecording(wavBlob);\n        } catch (error) {\n          console.error('Error processing audio:', error);\n          handleStatus('Failed to process recording. Please try again.', 'error');\n        } finally {\n          cleanupRecording();\n        }\n      };\n      mediaRecorderRef.current.start(100);\n      setIsRecording(true);\n      startCountdown();\n    } catch (err) {\n      console.error('Error starting recording:', err);\n      handleStatus('Failed to start recording. Please check microphone permissions.', 'error');\n      cleanupRecording();\n    }\n  };\n  const startCountdown = () => {\n    setCountdown(10);\n    countdownRef.current = setInterval(() => {\n      setCountdown(prev => {\n        if (prev <= 1) {\n          clearInterval(countdownRef.current);\n          stopRecording();\n          return 0;\n        }\n        return prev - 1;\n      });\n    }, 1000);\n  };\n  const stopRecording = () => {\n    try {\n      if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n        mediaRecorderRef.current.stop();\n      } else {\n        cleanupRecording();\n      }\n    } catch (err) {\n      console.error('Error stopping recording:', err);\n      handleStatus('Error stopping recording. Please try again.', 'error');\n      cleanupRecording();\n    }\n  };\n  const audioBufferToWav = audioBuffer => {\n    const numOfChan = audioBuffer.numberOfChannels;\n    const length = audioBuffer.length * numOfChan * 2;\n    const buffer = new ArrayBuffer(44 + length);\n    const view = new DataView(buffer);\n    const channels = [];\n    let sample;\n    let offset = 0;\n    let pos = 0;\n\n    // Write WAV header\n    setUint32(0x46464952); // \"RIFF\"\n    setUint32(36 + length); // file length\n    setUint32(0x45564157); // \"WAVE\"\n    setUint32(0x20746D66); // \"fmt \" chunk\n    setUint32(16); // length = 16\n    setUint16(1); // PCM (uncompressed)\n    setUint16(numOfChan);\n    setUint32(audioBuffer.sampleRate);\n    setUint32(audioBuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec\n    setUint16(numOfChan * 2); // block-align\n    setUint16(16); // 16-bit\n    setUint32(0x61746164); // \"data\" - chunk\n    setUint32(length); // chunk length\n\n    // Write interleaved data\n    for (let i = 0; i < audioBuffer.numberOfChannels; i++) {\n      channels.push(audioBuffer.getChannelData(i));\n    }\n    while (pos < audioBuffer.length) {\n      for (let i = 0; i < numOfChan; i++) {\n        sample = Math.max(-1, Math.min(1, channels[i][pos]));\n        sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;\n        view.setInt16(44 + offset, sample, true);\n        offset += 2;\n      }\n      pos++;\n    }\n    return buffer;\n    function setUint16(data) {\n      view.setUint16(pos, data, true);\n      pos += 2;\n    }\n    function setUint32(data) {\n      view.setUint32(pos, data, true);\n      pos += 4;\n    }\n  };\n  const processRecording = async blob => {\n    try {\n      let response;\n      if (mode === 'register') {\n        response = await registerVoice(blob, userData);\n      } else {\n        response = await loginVoice(blob, userData.username);\n      }\n      if (response.success) {\n        setPassphrase(response.passphrase || '');\n        handleStatus(response.message, 'success');\n      } else {\n        handleStatus(response.message, 'error');\n      }\n    } catch (err) {\n      console.error('Error processing recording:', err);\n      handleStatus('Failed to process recording. Please try again.', 'error');\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"panel\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"panel-title\",\n      children: [/*#__PURE__*/_jsxDEV(\"i\", {\n        className: \"fas fa-microphone\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 210,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"h2\", {\n        children: mode === 'register' ? 'Voice Registration' : 'Voice Authentication'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 211,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 209,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"buttons\",\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        className: `btn btn-primary ${isRecording ? 'disabled' : ''}`,\n        onClick: startRecording,\n        disabled: isRecording,\n        children: [/*#__PURE__*/_jsxDEV(\"i\", {\n          className: \"fas fa-microphone\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 220,\n          columnNumber: 21\n        }, this), mode === 'register' ? 'Record Passphrase' : 'Verify Identity']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 215,\n        columnNumber: 17\n      }, this), isRecording && /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"btn btn-danger\",\n        onClick: stopRecording,\n        children: [/*#__PURE__*/_jsxDEV(\"i\", {\n          className: \"fas fa-stop\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 228,\n          columnNumber: 25\n        }, this), \" Stop Recording\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 224,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 214,\n      columnNumber: 13\n    }, this), isRecording && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"recording-indicator\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"pulse\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 236,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          children: \"Recording your voice... Please speak now\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 237,\n          columnNumber: 25\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 235,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"timer\",\n        children: countdown\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 239,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"voice-wave\",\n        children: [...Array(8)].map((_, i) => /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"wave-bar\"\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 242,\n          columnNumber: 29\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 240,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true), passphrase && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"result-box\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"result-text\",\n        children: [\"Your \", mode === 'register' ? 'registered' : 'recognized', \" passphrase:\", /*#__PURE__*/_jsxDEV(\"span\", {\n          children: [\" \\\"\", passphrase, \"\\\"\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 252,\n          columnNumber: 25\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 250,\n        columnNumber: 21\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 249,\n      columnNumber: 17\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 208,\n    columnNumber: 9\n  }, this);\n};\n_s(VoiceRecorder, \"qG2QUNgwD7BrCv8Y2/BNeRmjsOk=\");\n_c = VoiceRecorder;\nexport default VoiceRecorder;\nvar _c;\n$RefreshReg$(_c, \"VoiceRecorder\");","map":{"version":3,"names":["React","useState","useEffect","useRef","registerVoice","loginVoice","jsxDEV","_jsxDEV","Fragment","_Fragment","VoiceRecorder","mode","userData","handleStatus","_s","isRecording","setIsRecording","countdown","setCountdown","audioBlob","setAudioBlob","passphrase","setPassphrase","mediaRecorderRef","audioChunksRef","countdownRef","cleanupRecording","current","state","stop","stream","getTracks","forEach","track","err","console","error","clearInterval","startRecording","navigator","mediaDevices","getUserMedia","audio","channelCount","sampleRate","options","mimeType","MediaRecorder","ondataavailable","e","data","size","push","onerror","event","onstop","length","Error","Blob","type","audioContext","window","AudioContext","webkitAudioContext","arrayBuffer","audioBuffer","decodeAudioData","wavBuffer","audioBufferToWav","wavBlob","processRecording","start","startCountdown","setInterval","prev","stopRecording","numOfChan","numberOfChannels","buffer","ArrayBuffer","view","DataView","channels","sample","offset","pos","setUint32","setUint16","i","getChannelData","Math","max","min","setInt16","blob","response","username","success","message","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","disabled","Array","map","_","_c","$RefreshReg$"],"sources":["C:/Users/Administrator/Desktop/voice-auth-system/frontend/src/components/VoiceRecorder.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\r\nimport { registerVoice, loginVoice } from '../utils/api';\r\n\r\nconst VoiceRecorder = ({ mode, userData, handleStatus }) => {\r\n    const [isRecording, setIsRecording] = useState(false);\r\n    const [countdown, setCountdown] = useState(10);\r\n    const [audioBlob, setAudioBlob] = useState(null);\r\n    const [passphrase, setPassphrase] = useState('');\r\n    const mediaRecorderRef = useRef(null);\r\n    const audioChunksRef = useRef([]);\r\n    const countdownRef = useRef(null);\r\n\r\n    // Cleanup function to ensure everything is reset\r\n    const cleanupRecording = () => {\r\n        if (mediaRecorderRef.current) {\r\n            try {\r\n                if (mediaRecorderRef.current.state !== 'inactive') {\r\n                    mediaRecorderRef.current.stop();\r\n                }\r\n                if (mediaRecorderRef.current.stream) {\r\n                    mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\r\n                }\r\n            } catch (err) {\r\n                console.error('Error in cleanup:', err);\r\n            }\r\n        }\r\n        if (countdownRef.current) {\r\n            clearInterval(countdownRef.current);\r\n        }\r\n        mediaRecorderRef.current = null;\r\n        audioChunksRef.current = [];\r\n        setIsRecording(false);\r\n        setCountdown(10);\r\n    };\r\n\r\n    useEffect(() => {\r\n        return () => {\r\n            cleanupRecording();\r\n        };\r\n    }, []);\r\n\r\n    const startRecording = async () => {\r\n        try {\r\n            // Clean up any existing recording first\r\n            cleanupRecording();\r\n\r\n            const stream = await navigator.mediaDevices.getUserMedia({ \r\n                audio: {\r\n                    channelCount: 1,\r\n                    sampleRate: 16000\r\n                } \r\n            });\r\n            \r\n            const options = { mimeType: 'audio/webm' };\r\n            mediaRecorderRef.current = new MediaRecorder(stream, options);\r\n            audioChunksRef.current = [];\r\n            \r\n            mediaRecorderRef.current.ondataavailable = (e) => {\r\n                if (e.data && e.data.size > 0) {\r\n                    audioChunksRef.current.push(e.data);\r\n                }\r\n            };\r\n            \r\n            mediaRecorderRef.current.onerror = (event) => {\r\n                console.error('Recording error:', event.error);\r\n                handleStatus('Error during recording. Please try again.', 'error');\r\n                cleanupRecording();\r\n            };\r\n            \r\n            mediaRecorderRef.current.onstop = async () => {\r\n                try {\r\n                    if (audioChunksRef.current.length === 0) {\r\n                        throw new Error('No audio data recorded');\r\n                    }\r\n\r\n                    const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });\r\n                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n                    const arrayBuffer = await audioBlob.arrayBuffer();\r\n                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\r\n                    \r\n                    const wavBuffer = audioBufferToWav(audioBuffer);\r\n                    const wavBlob = new Blob([wavBuffer], { type: 'audio/wav' });\r\n                    \r\n                    setAudioBlob(wavBlob);\r\n                    await processRecording(wavBlob);\r\n                } catch (error) {\r\n                    console.error('Error processing audio:', error);\r\n                    handleStatus('Failed to process recording. Please try again.', 'error');\r\n                } finally {\r\n                    cleanupRecording();\r\n                }\r\n            };\r\n\r\n            mediaRecorderRef.current.start(100);\r\n            setIsRecording(true);\r\n            startCountdown();\r\n            \r\n        } catch (err) {\r\n            console.error('Error starting recording:', err);\r\n            handleStatus('Failed to start recording. Please check microphone permissions.', 'error');\r\n            cleanupRecording();\r\n        }\r\n    };\r\n\r\n    const startCountdown = () => {\r\n        setCountdown(10);\r\n        countdownRef.current = setInterval(() => {\r\n            setCountdown(prev => {\r\n                if (prev <= 1) {\r\n                    clearInterval(countdownRef.current);\r\n                    stopRecording();\r\n                    return 0;\r\n                }\r\n                return prev - 1;\r\n            });\r\n        }, 1000);\r\n    };\r\n\r\n    const stopRecording = () => {\r\n        try {\r\n            if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\r\n                mediaRecorderRef.current.stop();\r\n            } else {\r\n                cleanupRecording();\r\n            }\r\n        } catch (err) {\r\n            console.error('Error stopping recording:', err);\r\n            handleStatus('Error stopping recording. Please try again.', 'error');\r\n            cleanupRecording();\r\n        }\r\n    };\r\n\r\n    const audioBufferToWav = (audioBuffer) => {\r\n        const numOfChan = audioBuffer.numberOfChannels;\r\n        const length = audioBuffer.length * numOfChan * 2;\r\n        const buffer = new ArrayBuffer(44 + length);\r\n        const view = new DataView(buffer);\r\n        const channels = [];\r\n        let sample;\r\n        let offset = 0;\r\n        let pos = 0;\r\n\r\n        // Write WAV header\r\n        setUint32(0x46464952);          // \"RIFF\"\r\n        setUint32(36 + length);         // file length\r\n        setUint32(0x45564157);          // \"WAVE\"\r\n        setUint32(0x20746D66);          // \"fmt \" chunk\r\n        setUint32(16);                  // length = 16\r\n        setUint16(1);                   // PCM (uncompressed)\r\n        setUint16(numOfChan);\r\n        setUint32(audioBuffer.sampleRate);\r\n        setUint32(audioBuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec\r\n        setUint16(numOfChan * 2);       // block-align\r\n        setUint16(16);                  // 16-bit\r\n        setUint32(0x61746164);          // \"data\" - chunk\r\n        setUint32(length);              // chunk length\r\n\r\n        // Write interleaved data\r\n        for (let i = 0; i < audioBuffer.numberOfChannels; i++) {\r\n            channels.push(audioBuffer.getChannelData(i));\r\n        }\r\n\r\n        while (pos < audioBuffer.length) {\r\n            for (let i = 0; i < numOfChan; i++) {\r\n                sample = Math.max(-1, Math.min(1, channels[i][pos]));\r\n                sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;\r\n                view.setInt16(44 + offset, sample, true);\r\n                offset += 2;\r\n            }\r\n            pos++;\r\n        }\r\n\r\n        return buffer;\r\n\r\n        function setUint16(data) {\r\n            view.setUint16(pos, data, true);\r\n            pos += 2;\r\n        }\r\n\r\n        function setUint32(data) {\r\n            view.setUint32(pos, data, true);\r\n            pos += 4;\r\n        }\r\n    };\r\n\r\n    const processRecording = async (blob) => {\r\n        try {\r\n            let response;\r\n            if (mode === 'register') {\r\n                response = await registerVoice(blob, userData);\r\n            } else {\r\n                response = await loginVoice(blob, userData.username);\r\n            }\r\n            \r\n            if (response.success) {\r\n                setPassphrase(response.passphrase || '');\r\n                handleStatus(response.message, 'success');\r\n            } else {\r\n                handleStatus(response.message, 'error');\r\n            }\r\n        } catch (err) {\r\n            console.error('Error processing recording:', err);\r\n            handleStatus('Failed to process recording. Please try again.', 'error');\r\n        }\r\n    };\r\n\r\n    return (\r\n        <div className=\"panel\">\r\n            <div className=\"panel-title\">\r\n                <i className=\"fas fa-microphone\"></i>\r\n                <h2>{mode === 'register' ? 'Voice Registration' : 'Voice Authentication'}</h2>\r\n            </div>\r\n            \r\n            <div className=\"buttons\">\r\n                <button \r\n                    className={`btn btn-primary ${isRecording ? 'disabled' : ''}`}\r\n                    onClick={startRecording}\r\n                    disabled={isRecording}\r\n                >\r\n                    <i className=\"fas fa-microphone\"></i> \r\n                    {mode === 'register' ? 'Record Passphrase' : 'Verify Identity'}\r\n                </button>\r\n                {isRecording && (\r\n                    <button \r\n                        className=\"btn btn-danger\"\r\n                        onClick={stopRecording}\r\n                    >\r\n                        <i className=\"fas fa-stop\"></i> Stop Recording\r\n                    </button>\r\n                )}\r\n            </div>\r\n            \r\n            {isRecording && (\r\n                <>\r\n                    <div className=\"recording-indicator\">\r\n                        <div className=\"pulse\"></div>\r\n                        <div>Recording your voice... Please speak now</div>\r\n                    </div>\r\n                    <div className=\"timer\">{countdown}</div>\r\n                    <div className=\"voice-wave\">\r\n                        {[...Array(8)].map((_, i) => (\r\n                            <div key={i} className=\"wave-bar\"></div>\r\n                        ))}\r\n                    </div>\r\n                </>\r\n            )}\r\n            \r\n            {passphrase && (\r\n                <div className=\"result-box\">\r\n                    <div className=\"result-text\">\r\n                        Your {mode === 'register' ? 'registered' : 'recognized'} passphrase: \r\n                        <span> \"{passphrase}\"</span>\r\n                    </div>\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default VoiceRecorder;"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAC1D,SAASC,aAAa,EAAEC,UAAU,QAAQ,cAAc;AAAC,SAAAC,MAAA,IAAAC,OAAA,EAAAC,QAAA,IAAAC,SAAA;AAEzD,MAAMC,aAAa,GAAGA,CAAC;EAAEC,IAAI;EAAEC,QAAQ;EAAEC;AAAa,CAAC,KAAK;EAAAC,EAAA;EACxD,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGf,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACgB,SAAS,EAAEC,YAAY,CAAC,GAAGjB,QAAQ,CAAC,EAAE,CAAC;EAC9C,MAAM,CAACkB,SAAS,EAAEC,YAAY,CAAC,GAAGnB,QAAQ,CAAC,IAAI,CAAC;EAChD,MAAM,CAACoB,UAAU,EAAEC,aAAa,CAAC,GAAGrB,QAAQ,CAAC,EAAE,CAAC;EAChD,MAAMsB,gBAAgB,GAAGpB,MAAM,CAAC,IAAI,CAAC;EACrC,MAAMqB,cAAc,GAAGrB,MAAM,CAAC,EAAE,CAAC;EACjC,MAAMsB,YAAY,GAAGtB,MAAM,CAAC,IAAI,CAAC;;EAEjC;EACA,MAAMuB,gBAAgB,GAAGA,CAAA,KAAM;IAC3B,IAAIH,gBAAgB,CAACI,OAAO,EAAE;MAC1B,IAAI;QACA,IAAIJ,gBAAgB,CAACI,OAAO,CAACC,KAAK,KAAK,UAAU,EAAE;UAC/CL,gBAAgB,CAACI,OAAO,CAACE,IAAI,CAAC,CAAC;QACnC;QACA,IAAIN,gBAAgB,CAACI,OAAO,CAACG,MAAM,EAAE;UACjCP,gBAAgB,CAACI,OAAO,CAACG,MAAM,CAACC,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACJ,IAAI,CAAC,CAAC,CAAC;QAC9E;MACJ,CAAC,CAAC,OAAOK,GAAG,EAAE;QACVC,OAAO,CAACC,KAAK,CAAC,mBAAmB,EAAEF,GAAG,CAAC;MAC3C;IACJ;IACA,IAAIT,YAAY,CAACE,OAAO,EAAE;MACtBU,aAAa,CAACZ,YAAY,CAACE,OAAO,CAAC;IACvC;IACAJ,gBAAgB,CAACI,OAAO,GAAG,IAAI;IAC/BH,cAAc,CAACG,OAAO,GAAG,EAAE;IAC3BX,cAAc,CAAC,KAAK,CAAC;IACrBE,YAAY,CAAC,EAAE,CAAC;EACpB,CAAC;EAEDhB,SAAS,CAAC,MAAM;IACZ,OAAO,MAAM;MACTwB,gBAAgB,CAAC,CAAC;IACtB,CAAC;EACL,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMY,cAAc,GAAG,MAAAA,CAAA,KAAY;IAC/B,IAAI;MACA;MACAZ,gBAAgB,CAAC,CAAC;MAElB,MAAMI,MAAM,GAAG,MAAMS,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QACrDC,KAAK,EAAE;UACHC,YAAY,EAAE,CAAC;UACfC,UAAU,EAAE;QAChB;MACJ,CAAC,CAAC;MAEF,MAAMC,OAAO,GAAG;QAAEC,QAAQ,EAAE;MAAa,CAAC;MAC1CvB,gBAAgB,CAACI,OAAO,GAAG,IAAIoB,aAAa,CAACjB,MAAM,EAAEe,OAAO,CAAC;MAC7DrB,cAAc,CAACG,OAAO,GAAG,EAAE;MAE3BJ,gBAAgB,CAACI,OAAO,CAACqB,eAAe,GAAIC,CAAC,IAAK;QAC9C,IAAIA,CAAC,CAACC,IAAI,IAAID,CAAC,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAE;UAC3B3B,cAAc,CAACG,OAAO,CAACyB,IAAI,CAACH,CAAC,CAACC,IAAI,CAAC;QACvC;MACJ,CAAC;MAED3B,gBAAgB,CAACI,OAAO,CAAC0B,OAAO,GAAIC,KAAK,IAAK;QAC1CnB,OAAO,CAACC,KAAK,CAAC,kBAAkB,EAAEkB,KAAK,CAAClB,KAAK,CAAC;QAC9CvB,YAAY,CAAC,2CAA2C,EAAE,OAAO,CAAC;QAClEa,gBAAgB,CAAC,CAAC;MACtB,CAAC;MAEDH,gBAAgB,CAACI,OAAO,CAAC4B,MAAM,GAAG,YAAY;QAC1C,IAAI;UACA,IAAI/B,cAAc,CAACG,OAAO,CAAC6B,MAAM,KAAK,CAAC,EAAE;YACrC,MAAM,IAAIC,KAAK,CAAC,wBAAwB,CAAC;UAC7C;UAEA,MAAMtC,SAAS,GAAG,IAAIuC,IAAI,CAAClC,cAAc,CAACG,OAAO,EAAE;YAAEgC,IAAI,EAAE;UAAa,CAAC,CAAC;UAC1E,MAAMC,YAAY,GAAG,KAAKC,MAAM,CAACC,YAAY,IAAID,MAAM,CAACE,kBAAkB,EAAE,CAAC;UAC7E,MAAMC,WAAW,GAAG,MAAM7C,SAAS,CAAC6C,WAAW,CAAC,CAAC;UACjD,MAAMC,WAAW,GAAG,MAAML,YAAY,CAACM,eAAe,CAACF,WAAW,CAAC;UAEnE,MAAMG,SAAS,GAAGC,gBAAgB,CAACH,WAAW,CAAC;UAC/C,MAAMI,OAAO,GAAG,IAAIX,IAAI,CAAC,CAACS,SAAS,CAAC,EAAE;YAAER,IAAI,EAAE;UAAY,CAAC,CAAC;UAE5DvC,YAAY,CAACiD,OAAO,CAAC;UACrB,MAAMC,gBAAgB,CAACD,OAAO,CAAC;QACnC,CAAC,CAAC,OAAOjC,KAAK,EAAE;UACZD,OAAO,CAACC,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;UAC/CvB,YAAY,CAAC,gDAAgD,EAAE,OAAO,CAAC;QAC3E,CAAC,SAAS;UACNa,gBAAgB,CAAC,CAAC;QACtB;MACJ,CAAC;MAEDH,gBAAgB,CAACI,OAAO,CAAC4C,KAAK,CAAC,GAAG,CAAC;MACnCvD,cAAc,CAAC,IAAI,CAAC;MACpBwD,cAAc,CAAC,CAAC;IAEpB,CAAC,CAAC,OAAOtC,GAAG,EAAE;MACVC,OAAO,CAACC,KAAK,CAAC,2BAA2B,EAAEF,GAAG,CAAC;MAC/CrB,YAAY,CAAC,iEAAiE,EAAE,OAAO,CAAC;MACxFa,gBAAgB,CAAC,CAAC;IACtB;EACJ,CAAC;EAED,MAAM8C,cAAc,GAAGA,CAAA,KAAM;IACzBtD,YAAY,CAAC,EAAE,CAAC;IAChBO,YAAY,CAACE,OAAO,GAAG8C,WAAW,CAAC,MAAM;MACrCvD,YAAY,CAACwD,IAAI,IAAI;QACjB,IAAIA,IAAI,IAAI,CAAC,EAAE;UACXrC,aAAa,CAACZ,YAAY,CAACE,OAAO,CAAC;UACnCgD,aAAa,CAAC,CAAC;UACf,OAAO,CAAC;QACZ;QACA,OAAOD,IAAI,GAAG,CAAC;MACnB,CAAC,CAAC;IACN,CAAC,EAAE,IAAI,CAAC;EACZ,CAAC;EAED,MAAMC,aAAa,GAAGA,CAAA,KAAM;IACxB,IAAI;MACA,IAAIpD,gBAAgB,CAACI,OAAO,IAAIJ,gBAAgB,CAACI,OAAO,CAACC,KAAK,KAAK,WAAW,EAAE;QAC5EL,gBAAgB,CAACI,OAAO,CAACE,IAAI,CAAC,CAAC;MACnC,CAAC,MAAM;QACHH,gBAAgB,CAAC,CAAC;MACtB;IACJ,CAAC,CAAC,OAAOQ,GAAG,EAAE;MACVC,OAAO,CAACC,KAAK,CAAC,2BAA2B,EAAEF,GAAG,CAAC;MAC/CrB,YAAY,CAAC,6CAA6C,EAAE,OAAO,CAAC;MACpEa,gBAAgB,CAAC,CAAC;IACtB;EACJ,CAAC;EAED,MAAM0C,gBAAgB,GAAIH,WAAW,IAAK;IACtC,MAAMW,SAAS,GAAGX,WAAW,CAACY,gBAAgB;IAC9C,MAAMrB,MAAM,GAAGS,WAAW,CAACT,MAAM,GAAGoB,SAAS,GAAG,CAAC;IACjD,MAAME,MAAM,GAAG,IAAIC,WAAW,CAAC,EAAE,GAAGvB,MAAM,CAAC;IAC3C,MAAMwB,IAAI,GAAG,IAAIC,QAAQ,CAACH,MAAM,CAAC;IACjC,MAAMI,QAAQ,GAAG,EAAE;IACnB,IAAIC,MAAM;IACV,IAAIC,MAAM,GAAG,CAAC;IACd,IAAIC,GAAG,GAAG,CAAC;;IAEX;IACAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAU;IAChCA,SAAS,CAAC,EAAE,GAAG9B,MAAM,CAAC,CAAC,CAAS;IAChC8B,SAAS,CAAC,UAAU,CAAC,CAAC,CAAU;IAChCA,SAAS,CAAC,UAAU,CAAC,CAAC,CAAU;IAChCA,SAAS,CAAC,EAAE,CAAC,CAAC,CAAkB;IAChCC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAmB;IAChCA,SAAS,CAACX,SAAS,CAAC;IACpBU,SAAS,CAACrB,WAAW,CAACrB,UAAU,CAAC;IACjC0C,SAAS,CAACrB,WAAW,CAACrB,UAAU,GAAG,CAAC,GAAGgC,SAAS,CAAC,CAAC,CAAC;IACnDW,SAAS,CAACX,SAAS,GAAG,CAAC,CAAC,CAAC,CAAO;IAChCW,SAAS,CAAC,EAAE,CAAC,CAAC,CAAkB;IAChCD,SAAS,CAAC,UAAU,CAAC,CAAC,CAAU;IAChCA,SAAS,CAAC9B,MAAM,CAAC,CAAC,CAAc;;IAEhC;IACA,KAAK,IAAIgC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvB,WAAW,CAACY,gBAAgB,EAAEW,CAAC,EAAE,EAAE;MACnDN,QAAQ,CAAC9B,IAAI,CAACa,WAAW,CAACwB,cAAc,CAACD,CAAC,CAAC,CAAC;IAChD;IAEA,OAAOH,GAAG,GAAGpB,WAAW,CAACT,MAAM,EAAE;MAC7B,KAAK,IAAIgC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,SAAS,EAAEY,CAAC,EAAE,EAAE;QAChCL,MAAM,GAAGO,IAAI,CAACC,GAAG,CAAC,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEV,QAAQ,CAACM,CAAC,CAAC,CAACH,GAAG,CAAC,CAAC,CAAC;QACpDF,MAAM,GAAG,CAAC,GAAG,GAAGA,MAAM,GAAG,CAAC,GAAGA,MAAM,GAAG,KAAK,GAAGA,MAAM,GAAG,KAAK,IAAI,CAAC;QACjEH,IAAI,CAACa,QAAQ,CAAC,EAAE,GAAGT,MAAM,EAAED,MAAM,EAAE,IAAI,CAAC;QACxCC,MAAM,IAAI,CAAC;MACf;MACAC,GAAG,EAAE;IACT;IAEA,OAAOP,MAAM;IAEb,SAASS,SAASA,CAACrC,IAAI,EAAE;MACrB8B,IAAI,CAACO,SAAS,CAACF,GAAG,EAAEnC,IAAI,EAAE,IAAI,CAAC;MAC/BmC,GAAG,IAAI,CAAC;IACZ;IAEA,SAASC,SAASA,CAACpC,IAAI,EAAE;MACrB8B,IAAI,CAACM,SAAS,CAACD,GAAG,EAAEnC,IAAI,EAAE,IAAI,CAAC;MAC/BmC,GAAG,IAAI,CAAC;IACZ;EACJ,CAAC;EAED,MAAMf,gBAAgB,GAAG,MAAOwB,IAAI,IAAK;IACrC,IAAI;MACA,IAAIC,QAAQ;MACZ,IAAIpF,IAAI,KAAK,UAAU,EAAE;QACrBoF,QAAQ,GAAG,MAAM3F,aAAa,CAAC0F,IAAI,EAAElF,QAAQ,CAAC;MAClD,CAAC,MAAM;QACHmF,QAAQ,GAAG,MAAM1F,UAAU,CAACyF,IAAI,EAAElF,QAAQ,CAACoF,QAAQ,CAAC;MACxD;MAEA,IAAID,QAAQ,CAACE,OAAO,EAAE;QAClB3E,aAAa,CAACyE,QAAQ,CAAC1E,UAAU,IAAI,EAAE,CAAC;QACxCR,YAAY,CAACkF,QAAQ,CAACG,OAAO,EAAE,SAAS,CAAC;MAC7C,CAAC,MAAM;QACHrF,YAAY,CAACkF,QAAQ,CAACG,OAAO,EAAE,OAAO,CAAC;MAC3C;IACJ,CAAC,CAAC,OAAOhE,GAAG,EAAE;MACVC,OAAO,CAACC,KAAK,CAAC,6BAA6B,EAAEF,GAAG,CAAC;MACjDrB,YAAY,CAAC,gDAAgD,EAAE,OAAO,CAAC;IAC3E;EACJ,CAAC;EAED,oBACIN,OAAA;IAAK4F,SAAS,EAAC,OAAO;IAAAC,QAAA,gBAClB7F,OAAA;MAAK4F,SAAS,EAAC,aAAa;MAAAC,QAAA,gBACxB7F,OAAA;QAAG4F,SAAS,EAAC;MAAmB;QAAAE,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAI,CAAC,eACrCjG,OAAA;QAAA6F,QAAA,EAAKzF,IAAI,KAAK,UAAU,GAAG,oBAAoB,GAAG;MAAsB;QAAA0F,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAK,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAC7E,CAAC,eAENjG,OAAA;MAAK4F,SAAS,EAAC,SAAS;MAAAC,QAAA,gBACpB7F,OAAA;QACI4F,SAAS,EAAE,mBAAmBpF,WAAW,GAAG,UAAU,GAAG,EAAE,EAAG;QAC9D0F,OAAO,EAAEnE,cAAe;QACxBoE,QAAQ,EAAE3F,WAAY;QAAAqF,QAAA,gBAEtB7F,OAAA;UAAG4F,SAAS,EAAC;QAAmB;UAAAE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAI,CAAC,EACpC7F,IAAI,KAAK,UAAU,GAAG,mBAAmB,GAAG,iBAAiB;MAAA;QAAA0F,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAC1D,CAAC,EACRzF,WAAW,iBACRR,OAAA;QACI4F,SAAS,EAAC,gBAAgB;QAC1BM,OAAO,EAAE9B,aAAc;QAAAyB,QAAA,gBAEvB7F,OAAA;UAAG4F,SAAS,EAAC;QAAa;UAAAE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAI,CAAC,mBACnC;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAQ,CACX;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACA,CAAC,EAELzF,WAAW,iBACRR,OAAA,CAAAE,SAAA;MAAA2F,QAAA,gBACI7F,OAAA;QAAK4F,SAAS,EAAC,qBAAqB;QAAAC,QAAA,gBAChC7F,OAAA;UAAK4F,SAAS,EAAC;QAAO;UAAAE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAM,CAAC,eAC7BjG,OAAA;UAAA6F,QAAA,EAAK;QAAwC;UAAAC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAK,CAAC;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAClD,CAAC,eACNjG,OAAA;QAAK4F,SAAS,EAAC,OAAO;QAAAC,QAAA,EAAEnF;MAAS;QAAAoF,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAM,CAAC,eACxCjG,OAAA;QAAK4F,SAAS,EAAC,YAAY;QAAAC,QAAA,EACtB,CAAC,GAAGO,KAAK,CAAC,CAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAACC,CAAC,EAAErB,CAAC,kBACpBjF,OAAA;UAAa4F,SAAS,EAAC;QAAU,GAAvBX,CAAC;UAAAa,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAA4B,CAC1C;MAAC;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACD,CAAC;IAAA,eACR,CACL,EAEAnF,UAAU,iBACPd,OAAA;MAAK4F,SAAS,EAAC,YAAY;MAAAC,QAAA,eACvB7F,OAAA;QAAK4F,SAAS,EAAC,aAAa;QAAAC,QAAA,GAAC,OACpB,EAACzF,IAAI,KAAK,UAAU,GAAG,YAAY,GAAG,YAAY,EAAC,cACxD,eAAAJ,OAAA;UAAA6F,QAAA,GAAM,KAAE,EAAC/E,UAAU,EAAC,IAAC;QAAA;UAAAgF,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAM,CAAC;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAC3B;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACL,CACR;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACA,CAAC;AAEd,CAAC;AAAC1F,EAAA,CA9PIJ,aAAa;AAAAoG,EAAA,GAAbpG,aAAa;AAgQnB,eAAeA,aAAa;AAAC,IAAAoG,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}